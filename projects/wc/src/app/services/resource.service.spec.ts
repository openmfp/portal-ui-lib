import { Resource, ResourceDefinition } from '../models/resource';
import { ApolloFactory } from './apollo-factory';
import { ResourceService } from './resource.service';
import { TestBed } from '@angular/core/testing';
import { Apollo } from 'apollo-angular';
import * as gqlBuilder from 'gql-query-builder';
import { of, throwError } from 'rxjs';

describe('ResourceService', () => {
  let service: ResourceService;
  let mockApollo: jest.Mocked<Apollo>;
  let mockApolloFactory: { apollo: jest.Mocked<Apollo> };

  beforeEach(() => {
    mockApollo = {
      subscribe: jest.fn(),
      mutate: jest.fn(),
      query: jest.fn(),
    } as unknown as jest.Mocked<Apollo>;

    mockApolloFactory = {
      apollo: mockApollo,
    };

    TestBed.configureTestingModule({
      providers: [
        ResourceService,
        { provide: ApolloFactory, useValue: mockApolloFactory },
      ],
    });

    service = TestBed.inject(ResourceService);

    // Reset Apollo mocks before each test
    jest.clearAllMocks();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('read', () => {
    it('should call Apollo subscribe with correct query for a specific resource', () => {
      const mockResourceId = 'test-resource-id';
      const mockOperation = 'test_operation';
      const mockFields = ['field1', 'field2'];
      mockApollo.subscribe.mockReturnValue(
        of({ data: { test_operation: { id: mockResourceId } } }),
      );

      service.read(mockResourceId, mockOperation, mockFields);

      // Get the actual query that would be generated by gqlBuilder
      const expectedQueryObj = gqlBuilder.subscription({
        operation: mockOperation,
        fields: mockFields,
        variables: { name: { type: 'String!' } },
      });

      // Verify Apollo was called with a query containing the expected query string
      expect(mockApollo.subscribe).toHaveBeenCalledWith({
        query: expect.anything(),
        variables: {
          name: mockResourceId,
        },
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.subscribe.mock.calls[0][0];
      expect(callArgs.query.loc.source.body).toContain(mockOperation);
      expect(callArgs.query.loc.source.body).toContain('subscription');
    });

    it('should transform the response correctly', (done) => {
      const mockResourceId = 'test-resource-id';
      const mockOperation = 'test_operation';
      const mockFields = ['field1', 'field2'];
      const mockResponse = { id: mockResourceId, name: 'Test Resource' };

      mockApollo.subscribe.mockReturnValue(
        of({ data: { [mockOperation]: mockResponse } }),
      );

      service
        .read(mockResourceId, mockOperation, mockFields)
        .subscribe((result) => {
          expect(result).toEqual(mockResponse);
          done();
        });
    });

    it('should handle errors', (done) => {
      const mockResourceId = 'test-resource-id';
      const mockOperation = 'test_operation';
      const mockFields = ['field1', 'field2'];
      const mockError = new Error('GraphQL error');

      jest.spyOn(console, 'error').mockImplementation();
      mockApollo.subscribe.mockImplementation(() => {
        return throwError(() => mockError);
      });

      service.read(mockResourceId, mockOperation, mockFields).subscribe({
        error: (result) => {
          expect(console.error).toHaveBeenCalledWith(
            'Error executing GraphQL query',
            mockError,
          );
          done();
        },
      });
    });
  });

  describe('list', () => {
    it('should call Apollo subscribe with correct query for listing resources', () => {
      const mockOperation = 'list_operation';
      const mockFields = ['field1', 'field2'];
      mockApollo.subscribe.mockReturnValue(
        of({ data: { [mockOperation]: [] } }),
      );

      service.list(mockOperation, mockFields);

      // Get the actual query that would be generated by gqlBuilder
      const expectedQueryObj = gqlBuilder.subscription({
        operation: mockOperation,
        fields: mockFields,
        variables: {},
      });

      // Verify Apollo was called with a query containing the expected query string
      expect(mockApollo.subscribe).toHaveBeenCalledWith({
        query: expect.anything(),
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.subscribe.mock.calls[0][0];
      expect(callArgs.query.loc.source.body).toContain(mockOperation);
      expect(callArgs.query.loc.source.body).toContain('subscription');
    });

    it('should transform the list response correctly', (done) => {
      const mockOperation = 'list_operation';
      const mockFields = ['field1', 'field2'];
      const mockResponse = [
        { id: '1', name: 'Resource 1' },
        { id: '2', name: 'Resource 2' },
      ];

      mockApollo.subscribe.mockReturnValue(
        of({ data: { [mockOperation]: mockResponse } }),
      );

      service.list(mockOperation, mockFields).subscribe((result) => {
        expect(result).toEqual(mockResponse);
        done();
      });
    });

    it('should handle list errors', (done) => {
      const mockOperation = 'list_operation';
      const mockFields = ['field1', 'field2'];
      const mockError = new Error('GraphQL error');

      jest.spyOn(console, 'error').mockImplementation();
      mockApollo.subscribe.mockImplementation(() => {
        return throwError(() => mockError);
      });

      service.list(mockOperation, mockFields).subscribe({
        error: (result) => {
          expect(console.error).toHaveBeenCalledWith(
            'Error executing GraphQL query: ',
            mockError,
          );
          done();
        },
      });
    });
  });

  describe('delete', () => {
    it('should call Apollo mutate with cluster-scoped mutation when scope is Cluster', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.delete(mockResource, mockResourceDefinition);

      // Check that Apollo mutate was called
      expect(mockApollo.mutate).toHaveBeenCalledWith({
        mutation: expect.anything(),
        variables: {
          name: 'test-resource',
          namespace: undefined,
        },
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.mutate.mock.calls[0][0];
      const queryString = callArgs.mutation.loc.source.body;

      // Verify query structure without depending on exact formatting
      expect(queryString).toContain('mutation');
      expect(queryString).toContain('test_group');
      expect(queryString).toContain('deleteTestResource');
    });

    it('should call Apollo mutate with namespaced mutation when scope is Namespaced', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Namespaced',
        namespace: 'test-namespace',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.delete(mockResource, mockResourceDefinition);

      // Check that Apollo mutate was called
      expect(mockApollo.mutate).toHaveBeenCalledWith({
        mutation: expect.anything(),
        variables: {
          name: 'test-resource',
          namespace: 'test-namespace',
        },
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.mutate.mock.calls[0][0];
      const queryString = callArgs.mutation.loc.source.body;

      // Verify query structure without depending on exact formatting
      expect(queryString).toContain('mutation');
      expect(queryString).toContain('test_group');
      expect(queryString).toContain('deleteTestResource');
      // Should include namespace in the variables
      expect(queryString).toMatch(/name:.+namespace/s);
    });

    it('should handle group names with dots correctly', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.complex.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.delete(mockResource, mockResourceDefinition);

      // Extract the query string from the call arguments
      const callArgs = mockApollo.mutate.mock.calls[0][0];
      const queryString = callArgs.mutation.loc.source.body;

      // Verify the group name was correctly transformed
      expect(queryString).toContain('test_complex_group');
      expect(queryString).not.toContain('test.complex.group');
    });

    it('should return the mutation result', (done) => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      const mockResponse = { data: { deleteTestResource: true } };
      mockApollo.mutate.mockReturnValue(of(mockResponse));

      service
        .delete(mockResource, mockResourceDefinition)
        .subscribe((result) => {
          expect(result).toEqual(mockResponse);
          done();
        });
    });

    it('should handle errors in delete operation', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      const mockError = new Error('Mutation error');
      mockApollo.mutate.mockImplementation(() => {
        return throwError(() => mockError);
      });

      const errorSpy = jest.fn();
      service.delete(mockResource, mockResourceDefinition).subscribe({
        next: () => fail('Expected an error'),
        error: errorSpy,
      });

      expect(mockApollo.mutate).toHaveBeenCalled();
      // Error handling is done at the application level, so we don't need to test it here
    });
  });

  describe('create', () => {
    it('should call Apollo mutate with correct input', () => {
      const mockResource: Resource = {
        metadata: {
          name: 'test-resource',
        },
        spec: {
          description: 'Test description',
          displayName: 'Test Display Name',
          type: 'account',
        },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'core.openmfp.org',
        plural: 'accounts',
        singular: 'account',
        kind: 'Account',
        scope: 'Cluster',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.create(mockResource, mockResourceDefinition);

      expect(mockApollo.mutate).toHaveBeenCalledWith({
        mutation: expect.anything(),
        fetchPolicy: 'no-cache',
        variables: { object: mockResource },
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.mutate.mock.calls[0][0];
      const queryString = callArgs.mutation.loc.source.body;

      // Verify query structure without depending on exact formatting
      expect(queryString).toContain('mutation');
      expect(queryString).toContain('core_openmfp_org');
      expect(queryString).toContain('createAccount');
      expect(queryString).toContain('__typename');
    });

    it('should handle group names with dots correctly for create operation', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
        spec: { type: 'resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.complex.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.create(mockResource, mockResourceDefinition);

      // Extract the query string from the call arguments
      const callArgs = mockApollo.mutate.mock.calls[0][0];
      const queryString = callArgs.mutation.loc.source.body;

      // Verify the group name was correctly transformed
      expect(queryString).toContain('test_complex_group');
      expect(queryString).not.toContain('test.complex.group');
    });

    it('should set fetchPolicy to no-cache', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
        spec: { type: 'resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      mockApollo.mutate.mockReturnValue(of({ data: null }));

      service.create(mockResource, mockResourceDefinition);

      expect(mockApollo.mutate).toHaveBeenCalledWith(
        expect.objectContaining({
          fetchPolicy: 'no-cache',
        }),
      );
    });

    it('should return the create mutation result', (done) => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
        spec: { type: 'resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      const mockResponse = {
        data: { createTestResource: { __typename: 'TestResource' } },
      };
      mockApollo.mutate.mockReturnValue(of(mockResponse));

      service
        .create(mockResource, mockResourceDefinition)
        .subscribe((result) => {
          expect(result).toEqual(mockResponse);
          done();
        });
    });

    it('should handle errors in create operation', () => {
      const mockResource: Resource = {
        metadata: { name: 'test-resource' },
        spec: { type: 'resource' },
      };

      const mockResourceDefinition: ResourceDefinition = {
        group: 'test.group',
        plural: 'resources',
        singular: 'resource',
        kind: 'TestResource',
        scope: 'Cluster',
      };

      const mockError = new Error('Mutation error');
      mockApollo.mutate.mockImplementation(() => {
        return throwError(() => mockError);
      });

      const errorSpy = jest.fn();
      service.create(mockResource, mockResourceDefinition).subscribe({
        next: () => fail('Expected an error'),
        error: errorSpy,
      });

      expect(mockApollo.mutate).toHaveBeenCalled();
    });
  });

  describe('readKcpCA', () => {
    it('should call Apollo query with correct query for reading KCP CA', () => {
      const mockResponse = {
        data: {
          core_openmfp_org: {
            AccountInfo: {
              metadata: {
                name: 'account',
              },
              spec: {
                clusterInfo: {
                  ca: 'mock-ca-data',
                }
              },
            },
          },
        },
        loading: false,
        networkStatus: 7,
      };

      mockApollo.query.mockReturnValue(of(mockResponse));

      service.readKcpCA();

      expect(mockApollo.query).toHaveBeenCalledWith({
        query: expect.anything(),
      });

      const callArgs = mockApollo.query.mock.calls[0][0];
      const queryString = callArgs.query.loc.source.body;

      // Verify query structure
      expect(queryString).toContain('core_openmfp_org');
      expect(queryString).toContain('AccountInfo');
      expect(queryString).toContain('account');
    });

    it('should return the correct response data', (done) => {
      const mockResponse = {
       data: {
          core_openmfp_org: {
            AccountInfo: {
              metadata: {
                name: 'account',
              },
              spec: {
                clusterInfo: {
                  ca: 'mock-ca-data',
                }
              },
            },
          },
        },
        loading: false,
        networkStatus: 7,
      };

      mockApollo.query.mockReturnValue(of(mockResponse));

      service.readKcpCA().subscribe((result) => {
        expect(result).toEqual('mock-ca-data');
        done();
      });
    });

    it('should handle errors', (done) => {
      const mockError = new Error('GraphQL error');
      mockApollo.query.mockImplementation(() => {
        return throwError(() => mockError);
      });

      service.readKcpCA().subscribe({
        error: (error) => {
          expect(error).toBe(mockError);
          done();
        },
      });
    });
  });

  describe('readOrganizations', () => {
    it('should call Apollo query with correct query for reading organizations', () => {
      const mockOperation = 'core_openmfp_org';
      const mockFields = ['name', 'namespace'];
      mockApollo.query.mockReturnValue(
        of({
          data: { [mockOperation]: [] },
          loading: false,
          networkStatus: 7,
        }),
      );

      service.readOrganizations(mockOperation, mockFields);

      // Get the actual query that would be generated by gqlBuilder
      const expectedQueryObj = gqlBuilder.query({
        operation: mockOperation,
        fields: mockFields,
        variables: {},
      });

      // Verify Apollo was called with a query containing the expected query string
      expect(mockApollo.query).toHaveBeenCalledWith({
        query: expect.anything(),
      });

      // Extract the query string from the call arguments
      const callArgs = mockApollo.query.mock.calls[0][0];
      expect(callArgs.query.loc.source.body).toContain(mockOperation);
      expect(callArgs.query.loc.source.body).toContain('query');
    });

    it('should transform the organizations response correctly', (done) => {
      const mockOperation = 'core_openmfp_org';
      const mockFields = ['name'];
      const mockResponse = {
        Accounts: [
          { metadata: { name: 'org1' } },
          { metadata: { name: 'org2' } },
        ],
      };

      mockApollo.query.mockReturnValue(
        of({
          data: { [mockOperation]: mockResponse },
          loading: false,
          networkStatus: 7,
        }),
      );

      service
        .readOrganizations(mockOperation, mockFields)
        .subscribe((result) => {
          expect(result).toEqual(mockResponse);
          done();
        });
    });

    it('should handle errors in readOrganizations', (done) => {
      const mockOperation = 'core_openmfp_org';
      const mockFields = ['name'];
      const mockError = new Error('GraphQL error');

      jest.spyOn(console, 'error').mockImplementation();
      mockApollo.query.mockImplementation(() => {
        return throwError(() => mockError);
      });

      service.readOrganizations(mockOperation, mockFields).subscribe({
        error: (error) => {
          expect(console.error).toHaveBeenCalledWith(
            'Error executing GraphQL query',
            mockError,
          );
          done();
        },
      });
    });

    it('should handle empty response data', (done) => {
      const mockOperation = 'core_openmfp_org';
      const mockFields = ['name'];

      mockApollo.query.mockReturnValue(
        of({
          data: { [mockOperation]: null },
          loading: false,
          networkStatus: 7,
        }),
      );

      service
        .readOrganizations(mockOperation, mockFields)
        .subscribe((result) => {
          expect(result).toBeNull();
          done();
        });
    });

    it('should use correct query structure with fields', () => {
      const mockOperation = 'core_openmfp_org';
      const mockFields = ['name', 'namespace'];

      mockApollo.query.mockReturnValue(
        of({
          data: { [mockOperation]: [] },
          loading: false,
          networkStatus: 7,
        }),
      );

      service.readOrganizations(mockOperation, mockFields);

      const callArgs = mockApollo.query.mock.calls[0][0];
      const queryString = callArgs.query.loc.source.body;

      expect(queryString).toContain('query');
      expect(queryString).toContain(mockOperation);
      mockFields.forEach((field) => {
        expect(queryString).toContain(field.split('.').pop());
      });
    });
  });
});
